#!/bin/bash
# SPDX-License-Identifier: Apache-2.0
# Copyright (C) 2022 OKTET Labs Ltd. All rights reserved.

set -u

NOTOK=0

reflist="$(mktemp)"
cat >"${reflist}"
trap 'rm "${reflist}"' EXIT

# Run a user chain hook if it is present
if [[ -x "${0}.chain" ]]; then
    "${0}.chain" "$@" < "${reflist}"
    NOTOK="$?"
fi

# Map commit ids to patch names if they are known.
# Currently only stgit patches are recognized, but
# other tools may be supported in the future.
declare -A COMMIT_NAMES
if command -v stg >/dev/null 2>/dev/null; then
    for pname in $(stg series -a --noprefix 2>/dev/null); do
        rev="$(stg id "${pname}")"
        COMMIT_NAMES[${rev}]="${pname}"
    done
fi

# The lines starting with three hashes will be
# output by ol_install_hook --list-checks.

# The lines starting with two dashes and a bang
# provide a list of configuration options with short
# descriptions

### If hooks.push-disable-checks option is set to YES
### (mind the upper case!), then all checks are
### disabled. Of course, this option shall only be specified
### in a command line, not in any config file
###
##! push-disable-checks If set to YES, all checks are disabled.

if [[ "$(git config --default "" --get hooks.push-disable-checks)" == "YES" ]];
then
    case "$(git config --show-origin --get hooks.push-disable-checks YES)" in
        command\ line:*)
            echo "WARNING: bypassing ALL the checks" >&2
            exit "${NOTOK}"
            ;;
        *)
            echo "WARNING: cannot disable checks from config file" >&2
            ;;
    esac
fi


### If hooks.push-maintainer option is enabled,
### then most errors are downgraded to warnings.
### The affected checks are marked with M in the list below.
###
### The maintainer mode may only be enable via command line,
### not from a config file.
###
##! push-maintainer Downgrade some errors to warnings (consult --list-checks for details)

MAINTAINER_PUSH="$(git config --default false --type bool \
                       --get hooks.push-maintainer)"
if [[ "${MAINTAINER_PUSH}" == "true" ]]; then
    case "$(git config --show-origin --get hooks.push-maintainer true)" in
        command\ line:*)
            echo "WARNING: enabled maintainer mode,"  \
                 "some errors are downgraded to warnings" >&2
            ;;
        *)
            echo "WARNING: cannot enable maintainer mode from config file" >&2
            MAINTAINER_PUSH=false
            ;;
    esac
fi

### If hooks.push-verbose-checks is enabled,
### the hashes of revisions being checked will be printed.
### This may be useful when a long series of commits is checked.
###
##! push-verbose-checks Enable printing the revisions being checked.

if [[ -z "${PUSH_VERBOSE_CHECKS:-}" ]]; then
    PUSH_VERBOSE_CHECKS="$(git config --default false --type bool \
                               --get hooks.push-verbose-checks)"
fi

##! push-standard-git-revert Accept commit message autogenerated by git revert
ALLOW_STANDARD_GIT_REVERT="$(git config --default false --type bool \
                                 --get hooks.push-standard-git-revert)"

Z40='0000000000000000000000000000000000000000'
EMPTYTREE='4b825dc642cb6eb9a060e54bf8d69288fbee4904'
ERRORS=
WARNINGS=
PRODUCTION_BRANCH=

function get_trailer ()
{
    git log -1 --format="%(trailers:key=$1,valueonly)" "$2"
}

function extract_mail ()
{
    sed -n 's/^.*<\([^>]*\)>$/\1/p'
}

function get_parent ()
{
    local rev="$1"

    if git rev-parse -q --verify "${rev}^" >/dev/null; then
        echo "${rev}^"
    else
        echo "${EMPTYTREE}"
    fi
}

KNOWN_TRAILERS=(Signed-off-by Co-developed-by Reviewed-by Acked-by \
                              Tested-by Suggested-by Reported-by OL-Redmine-Id \
                              GitHub-TE-Id AMD-Jira-Id \
                              Fixes Fixes-Private Ref Breaks Urgency Link)

function strip_known_trailers ()
{
    local filters=

    for trailer in "${KNOWN_TRAILERS[@]}"; do
        filters+="/^${trailer}:/Id;"
    done
    git interpret-trailers --unfold | sed "${filters}"
}

EMAIL_SYNTAX="[[:upper:]]+([[:alpha:]. -]) <+([[:lower:][:digit:]+_.-])@+([[:lower:][:digit:]-])+(.+(+([[:lower:][:digit:]-])))>"

declare -A TRAILER_SYNTAX
TRAILER_SYNTAX=(["OL-Redmine-Id"]="+([[:digit:]])"
                ["GitHub-TE-Id"]="+([[:digit:]])"
                ["AMD-Jira-Id"]="+([[:upper:]])-+([[:digit:]])"
                ["Link"]="@(http|https|git)://+([[:alnum:]-])+(.+([[:alnum:]-]))*([^[:space:]{}])"
                ["Urgency"]="@(low|medium|high|emergency|critical)?( (*))"
                ["Ref"]="?(+([[:alnum:].-]):+([[:alnum:]_-])/+([[:alnum:]-])@)+([[:xdigit:]]) (\"*\")"
                ["Signed-off-by"]="${EMAIL_SYNTAX}"
                ["Co-developed-by"]="${EMAIL_SYNTAX}"
                ["Reviewed-by"]="${EMAIL_SYNTAX}"
                ["Acked-by"]="${EMAIL_SYNTAX}"
                ["Tested-by"]="${EMAIL_SYNTAX}"
                ["Suggested-by"]="${EMAIL_SYNTAX}"
                ["Reported-by"]="${EMAIL_SYNTAX}")

declare -A TRAILER_ORDER
declare -A TRAILER_NEXT_ORDER

# Trailers are divided into several groups which
# should come in a certain order, but the relative
# ordering of different trailers within one group
# is not specified. Thus each trailer is assigned its
# order group number. In general, the group number of
# a next trailer must not be less than the number of
# a previous trailer. However, some groups may be
# repeated, so for some trailers the minimal next
# allowed group number is one less that the current one.

TRAILER_ORDER=(["OL-Redmine-Id"]=0
               ["GitHub-TE-Id"]=0
               ["AMD-Jira-Id"]=0
               ["Link"]=0
               ["Fixes"]=0
               ["Fixes-Private"]=0
               ["Ref"]=0
               ["Breaks"]=0
               ["Urgency"]=0
               ["Suggested-by"]=1
               ["Reported-by"]=1
               ["Signed-off-by"]=2
               ["Co-developed-by"]=2
               ["Reviewed-by"]=3
               ["Acked-by"]=3
               ["Tested-by"]=3)

TRAILER_NEXT_ORDER=(["Reviewed-by"]=2
                    ["Acked-by"]=2
                    ["Tested-by"]=2)

function serious_error ()
{
    ERRORS+=$'\n\t'"$1"
    NOTOK=1
}

function warning ()
{
    WARNINGS+=$'\n\tWARNING: '"$1"
}

### A push to a non-public branch uses less strict
### checks: some errors are downgraded to warnings,
### and some are disabled altogether.
### Such checks are marked with P in the list below.
###
### The list of production branch names may be
### specified in a multi-valued parameter hooks.push-production-branch.
###
##! push-production-branch Names of branches that are treated as production.

PROD_BRANCHES="$(git config --get-all hooks.push-production-branch)"
if [[ -z "${PROD_BRANCHES}" ]]; then
    PROD_BRANCHES=main
fi

function production_error ()
{
    if [[ -n "${PRODUCTION_BRANCH}" ]]; then
        serious_error "$1"
    else
        warning "$1"
    fi
}

function nonmaintainer_error ()
{
    if [[ "${MAINTAINER_PUSH}" == "false" ]]; then
        serious_error "$1"
    else
        warning "$1"
    fi
}

function public_error ()
{
    if [[ -z "${PRIVATE_BRANCH}" ]]; then
        serious_error "$1"
    else
        warning "$1"
    fi
}

### The following checks are performed:
###

### - the presence of Signed-off-by trailer;
function check_signed_off ()
{
    local rev="$1"
    local signed_off

    signed_off="$(get_trailer Signed-off-by "${rev}")"
    if [[ -z "${signed_off}" ]]; then
        serious_error 'no Signed-off-by'
    fi
}

### - the matching number of Co-developed-by and Signed-off-by
###   trailers;
###
function check_co_developers ()
{
    local rev="$1"
    local -a participants
    local main_author
    local committer
    local line
    local email
    local codev=
    local signed_author=
    local need_signed_committer=
    local duplicates

    readarray -t participants < <(git log -1 --format="%(trailers)" "${rev}")

    main_author="$(git log -1 --format='%ae' "${rev}")"
    main_author="${main_author,,}"
    committer="$(git log -1 --format='%ce' "${rev}")"
    committer="${committer,,}"

    # The guidelines of kernel.org are followed:
    # - each Co-developed-by must be immediately followed by Signed-off-by;
    # - there must be a Signed-off-by from the commit author;
    # - there may be additional Signed-off-by from people not mentioned;
    #   elsewhere; this is possible if a patch passes through several stages;
    # - if there are co-developers after the author, the last Signed-off-by
    #   should be by the actual committer.
    for line in "${participants[@]}"; do
        [[ -z "${line}" ]] && continue

        shopt -s nocasematch
        case "${line}" in
            co-developed-by:*)
                email="$(echo "${line}" | extract_mail)"
                if [[ -n "${codev}" ]]; then
                    serious_error \
                    "Co-developed-by ${codev} is not followed by Signed-off-by"
                fi
                codev="${email}"
                ;;
            signed-off-by:*)
                email="$(echo "${line}" | extract_mail)"
                if [[ -n "${codev}" ]]; then
                    if [[ "${codev}" != "${email}" ]]; then
                        serious_error \
                            "Expected Signed-off-by ${codev}, got ${email}"
                    fi
                    codev=
                fi
                if [[ -n "${signed_author}" ]]; then
                    need_signed_committer=yes
                fi
                if [[ "${email}" == "${main_author}" ]]; then
                    signed_author=yes
                fi
                ;;
            *)
                if [[ -n "${codev}" ]]; then
                    serious_error \
                    "Co-developed-by ${codev} is not followed by Signed-off-by"
                fi
                codev=
                ;;
        esac
        shopt -u nocasematch
    done
    if [[ -n "${codev}" ]]; then
        serious_error \
            "Co-developed-by ${codev} is not followed by Signed-off-by"
    fi
    if [[ -z "${signed_author}" ]]; then
        serious_error "No Signed-off-by from the main author ${main_author}"
    fi
    if [[ -n "${need_signed_committer}" && "${email}" != "${committer}" ]]; then
        nonmaintainer_error "The last Signed-off-by should be from ${committer}"
    fi

    duplicates="$(get_trailer Signed-off-by "${rev}" | extract_mail \
                              | sort | uniq -d)"
    if [[ -n "${duplicates}" ]]; then
        serious_error \
            "the same developers are mentioned several times: ${duplicates}"
    fi
}

### - the presence of at least one of Reviewed-by, Acked-by or Tested-by
###   (M, P); the check is completely disabled for non-public branches;
function check_reviewed_by ()
{
    local rev="$1"
    local reviewed_by
    local acked_by
    local tested_by
    local urgency

    if [[ -z "${PRIVATE_BRANCH}" ]]; then
        reviewed_by="$(get_trailer Reviewed-by "${rev}")"
        acked_by="$(get_trailer Acked-by "${rev}")"
        tested_by="$(get_trailer Tested-by "${rev}")"

        if [[ -z "${reviewed_by}${acked_by}${tested_by}" ]]; then
            urgency="$(get_trailer Urgency "${rev}")"

            case "${urgency}" in
                critical\ \(*\)|emergency\ \(*\))
                    warning 'no Reviewed-by, Acked-by or Tested-by for a critical patch'
                    ;;
                critical|emergency)
                    serious_error 'no explanation for the patch urgency'
                    ;;
                *)
                    serious_error 'no Reviewed-by, Acked-by or Tested-by'
                    ;;
            esac
        fi
    fi
}

### - the absence of duplicate Reviewed-By, Tested-By and Acked-by trailers
###   (mentioning the same person in different review trailers does not make
###    any sense, so it must be an error);
###
function check_reviewed_by_dups ()
{
    local rev="$1"
    local duplicates
    local fmt="%(trailers:key=Reviewed-by,key=Acked-by,key=Tested-by,valueonly)"

    duplicates="$(git log -1 --format="${fmt}" "${rev}" \
                      | extract_mail | sort | uniq -d)"
    if [[ -n "${duplicates}" ]]; then
        nonmaintainer_error \
            "the same reviewers are mentioned several times: ${duplicates}"
    fi
}

### - proper capitalization of all trailers specified in
###   the Contributor's Guideline (M);
###
function check_capitalization ()
{
    local rev="$1"
    local trailer
    local trailer0

    for trailer in "${KNOWN_TRAILERS[@]}"; do
        while IFS=: read -r trailer0 rest; do
            [[ -z "${trailer0}" ]] && continue
            if [[ "${trailer}" != "${trailer0}" ]]; then
                nonmaintainer_error "${trailer0} miscapitalized"
            fi
        done < <(git log -1 \
                     --format="%(trailers:key=${trailer},unfold)" \
                     "${rev}")
    done
}

### - the correctness of syntax of certain trailers:
###   + Signed-off-by, Co-developed-by, Reviewed-by, Acked-by, Tested-by,
###     Reported-by, Suggested-by shall all contain a valid lowercase email,
###     e.g.: Reviewed-by: John R. Hacker <john.r.hacker@example.com>;
###   + OL-Redmine-Id and GitHub-TE-Id shall contain only numbers;
###   + AMD-Jira-Id shall be a Jira identifier (like XXX-9999);
###   + Urgency shall have the form: LEVEL (OPTIONAL MESSAGE);
###   + Ref shall have the form [ORGANIZATION/REPO@]HASH ("SUBJECT");
###   + Link shall be a HTTP(S) or Git URL; (M)
###
function check_trailer_syntax ()
{
    local rev="$1"
    local trailer
    local value

    for trailer in "${!TRAILER_SYNTAX[@]}"; do
        while read -r value; do
            [[ -z "${value}" ]] && continue

            # shellcheck disable=SC2053
            if [[ "${value}" != ${TRAILER_SYNTAX[${trailer}]} ]]; then
                nonmaintainer_error "invalid value '${value}' for ${trailer}"
            fi
        done < <(git log -1 \
                     --format="%(trailers:key=${trailer},valueonly,unfold)" \
                     "${rev}")
    done
}

### - the recommended order of trailer groups:
###   + Fixes, Fixes-Private, Ref, Breaks, Urgency, OL-Redmine-Id,
###     GitHub-TE-Id, AMD-Jira-Id in any order;
###   + Suggested-by and Reported-by;
###   + Signed-off-by and Co-developed-by;
###   + Reviewed-by, Acked-by, Tested-by;
###   this check is always reported as a warning;
###
function check_trailer_ordering ()
{
    local rev="$1"
    local prev_trailer
    local trailer
    local rest
    local cur_order
    local next_order
    local has_review

    has_review=
    cur_order=0
    next_order=0
    while IFS=: read -r trailer rest; do
        [[ -z "${trailer}" ]] && continue
        cur_order="${TRAILER_ORDER[${trailer}]:-}"
        # Unknown trailers are silently ignored wrt ordering
        [[ -z "${cur_order}" ]] && continue
        if [[ ${cur_order} -lt ${next_order} ]]; then
            warning "${trailer} should come before ${prev_trailer}"
        fi
        if [[ ${cur_order} -eq ${TRAILER_ORDER[Reviewed-by]} ]]; then
            has_review=true
        fi
        next_order="${TRAILER_NEXT_ORDER[${trailer}]:-${cur_order}}"
        prev_trailer="${trailer}"
    done < <(git log -1 --format="%(trailers:unfold)" "${rev}")
    if [[ -n "${has_review}" &&
              ${cur_order} -eq ${TRAILER_ORDER[Signed-off-by]} ]]; then
        warning "final ${prev_trailer} is not followed by a review trailer"
    fi
}

### - the correctness of Fixes, Fixes-Private and local Ref trailers;
###
function check_fixes ()
{
    local rev="$1"
    local hash
    local subject
    local subject0

    while read -r hash subject; do
        [[ -z "${hash}" ]] && continue
        if ! git merge-base --is-ancestor "${hash}" "${rev}" 2>/dev/null; then
            public_error "invalid Fixes commit ${hash}"
        else
            subject0="$(git log -1 --abbrev=12 \
                            --format='%h ("%s")' "${hash}")"
            if [[ "${hash} ${subject}" != "${subject0}" ]]; then
                nonmaintainer_error "malformatted Fixes line"
            fi
        fi
    done < <(git log -1 \
                 --format="%(trailers:key=Fixes,valueonly,unfold)" \
                 "${rev}")

    while read -r hash subject; do
        [[ -z "${hash}" ]] && continue
        if ! git rev-parse -q --verify "${hash}" >/dev/null 2>/dev/null; then
            serious_error "invalid Fixes-Private commit ${hash}"
        else
            if git merge-base --is-ancestor "${hash}" "${rev}" 2>/dev/null; then
                warning "Fixes-Private references a public changeset, consider using plain Fixes"
            fi
            subject0="$(git log -1 --abbrev=12 \
                            --format='%h ("%s")' "${hash}")"
            if [[ "${hash} ${subject}" != "${subject0}" ]]; then
                nonmaintainer_error "malformatted Fixes-Private line"
            fi
        fi
    done < <(git log -1 \
                 --format="%(trailers:key=Fixes-Private,valueonly,unfold)" \
                 "${rev}")

    while read -r hash subject; do
        [[ -z "${hash}" || "${hash}" == *@* ]] && continue
        if ! git rev-parse -q --verify "${hash}" >/dev/null 2>/dev/null; then
            serious_error "invalid local Ref commit ${hash}"
        else
            subject0="$(git log -1 --abbrev=12 \
                            --format='%h ("%s")' "${hash}")"
            if [[ "${hash} ${subject}" != "${subject0}" ]]; then
                nonmaintainer_error "malformatted Ref line"
            fi
        fi
    done < <(git log -1 \
                 --format="%(trailers:key=Ref,valueonly,unfold)" \
                 "${rev}")
}

### - several checks for the summary:
###
function check_summary ()
{
    local rev="$1"
    local subject

    if [[ "${ALLOW_STANDARD_GIT_REVERT}" == "true" && -n "${IS_REVERT}" ]]; then
        return 0
    fi

    subject="$(git log -1 --format='%s' "${rev}")"
    case "${subject}" in
        \[*)
            ###   + no series indicators (e.g. [1/5]) (P);
            production_error 'summary contains series indicators'
            ;;
        [Bb]ug* | [Tt]ask* | [Ss]tory*)
            ###   + no old-style Bug/Task/Story prefixes;
            serious_error 'old-style summary with an issue id'
            ;;
        *:\ [[:upper:]]* | [[:upper:]]*)
            ###   + no upper case letter at the start of the summary;
            serious_error 'summary should not start with an upper case'
            ;;
        */*/*:*)
            ###   + three or more levels in a component name;
            serious_error 'component name too deep'
            ;;
        *:*)
            ###   + not too long summary (P);
            if [[ "${#subject}" -gt 60 ]]; then
                production_error "too long summary (${#subject} characters)"
            fi
            ;;
        *)
            ###   + the absence of a component name (M);
            nonmaintainer_error 'no component name'
            ;;
    esac
}

### - no lines longer than 72 characters except some trailers (M);
###
function check_description ()
{
    local rev="$1"

    if [[ -n "$(git log -1 --format=%b  "${rev}" \
                    | strip_known_trailers \
                    | sed 's/^.\{1,72\}//')" ]];
    then
        production_error 'overlong lines in description'
    fi
}

# The following two checks are adapted from the default Git pre-commit hook

### - the absence of whitespace errors in the patch (M);
###   the kind of detected whitespace errors is controlled by core.whitespace
###   option (see man git-config);
###
function check_whitespaces ()
{
    local rev="$1"
    local parent
    local whitespace

    [[ -n "${IS_REVERT}" ]] && return 0

    parent="$(get_parent "${rev}")"

    if ! whitespace="$(git diff --check "${parent}" "${rev}")"; then
        nonmaintainer_error "${whitespace}"
    fi

}

### - the absence of non-printable and non-ASCII characters in filenames;
###   the check may be disabled by setting hooks.allownonascii = true,
###   just as with the Git default pre-commit hook (see man githooks);
###
##! allownonascii Enable non-ASCII characters in filenames and source code.
function check_nonascii ()
{
    local rev="$1"
    local parent
    local allownonascii

    [[ -n "${IS_REVERT}" ]] && return 0

    allownonascii="$(git config --default false --type bool \
                         --get hooks.allownonascii)"
    [[ "${allownonascii}" == "true" ]] && return 0

    parent="$(get_parent "${rev}")"

    if git diff --name-only --diff-filter=A -z "${parent}" "${rev}" \
            |  LC_CTYPE=C grep -z -q -E '[^[:graph:]]|[~#]'; then
        nonmaintainer_error "invalid filenames found"
    fi

}

### - the absence of non-ASCII characters in file bodies;
###   this check may be disabled by setting hooks.allownonascii = true
###   (which would also enable non-ASCII characters in file names, see
###   above) or hooks.allownonascii-body = true (M);
###
##! allownonascii-body Enable non-ASCII characters in source code, but not in filenames.
function check_nonascii_body ()
{
    local rev="$1"
    local parent
    local allownonascii
    local allownonascii_body
    local edited_file

    [[ -n "${IS_REVERT}" ]] && return 0

    allownonascii="$(git config --default false --type bool \
                         --get hooks.allownonascii)"
    allownonascii_body="$(git config --default false --type bool \
                                 --get hooks.allownonascii-body)"
    [[ "${allownonascii}" == "true"
       || "${allownonascii_body}" == "true" ]] && return 0

    parent="$(get_parent "${rev}")"

    for edited_file in $(git diff --diff-filter=d --name-only "${parent}" "${rev}")
    do
        local bad_lines

        bad_lines="$(LC_CTYPE=C LC_COLLATE=C \
                     git difftool -y -x "diff --old-line-format='' \
                                              --unchanged-line-format='' \
                                              --new-line-format='%6dn %L'" \
                                        "${parent}" "${rev}" "${edited_file}" \
                     | grep --no-messages --color=always \
                            --perl-regexp '[^\n\t -~]')"

        if [[ -n "${bad_lines}" ]]; then
            nonmaintainer_error "invalid characters in '${edited_file}':"$'\n'"${bad_lines}"
        fi
    done
}

###
### The following checks are optional and need to be explicitly enabled
### by setting Git options:
###

### - the approval by specific people; their emails should be listed
###   in hooks.push-require-approval option; the check is always skipped
###   in maintainer mode and for non-production branches;
##! push-require-approval Emails of people that must approve a patch.

function check_required_review ()
{
    local rev="${rev}"
    local emails
    local fmt="%(trailers:key=Reviewed-by,key=Acked-by,key=Tested-by,valueonly)"
    local required

    emails="$(git log -1 --format="${fmt}" "${rev}" | extract_mail)"

    [[ "${MAINTAINER_PUSH}" == "true" || -z "${PRODUCTION_BRANCH}" ]] \
        && return 0

    [[ -z "$(git config --default '' --get hooks.push-require-approval)" ]] \
        && return 0

    for required in ${emails}; do
        [[ -n "$(git config --get hooks.push-require-approval \
                    "${required}")" ]] && return 0
    done

    serious_error 'no required reviewer is present'
}

### - the absence of any trailer listed in hooks.push-prohibit-trailer
###   option (such trailers may contain service information, e.g.
###   a Reviewboard id which must be cleaned up before pushing);
###   the error is downgraded to a warning for user private branches;
###
##! push-prohibit-trailer List of trailers that must not appear in commit messages.
function check_prohibited_trailers ()
{
    local rev="$1"
    local notrailer
    local trailer

    for notrailer in $(git config --get-all hooks.push-prohibit-trailer); do
        trailer="$(get_trailer "${notrailer}" "${rev}")"
        if [[ -n "${trailer}" ]]; then
            public_error "${notrailer} is prohibited"
        fi
    done
}

### - the obligatory presence of any additional trailer listed in
###   hooks.push-require-trailer option (e.g. a trailer that contains
###   an issue tracker id which is not required by the Contributor's
###   guidelines but may be enforced by individual developers for their
###   patches); several trailer names may be separated by a pipe symbol
###   meaning that any of the provided variants need to be present;
###   for example:
###       git config --local hooks.push-require-trailer 'OL-Redmine-Id|GitHub-TE-Id|AMD-Jira-Id'
###   may be used to require some bug reference id in all patches;
###       git config --local --add hooks.push-require-trailer Reviewed-by
###   would add a second required trailer (Reviewed-by in this case);
###   the error is downgraded to a warning for user private branches;
###
##! push-require-trailer List of trailers that must be present in commit messages.
function check_extra_trailers ()
{
    local rev="$1"
    local reqtrailer
    local trailer
    local alt
    local found

    for reqtrailer in $(git config --get-all hooks.push-require-trailer); do
        found=
        for alt in ${reqtrailer//|/ }; do
            trailer="$(get_trailer "${alt}" "${rev}")"
            if [[ -n "${trailer}" ]]; then
                found=1
                break
            fi
        done
        if [[ -z "${found}" ]]; then
            public_error "${reqtrailer} is not present"
        fi
    done
}

### - the absence of suspicious trailer-like lines separated from the rest of
###   trailers by empty lines (such lines are not interpreted as trailers by
###   Git and are most probably a result of an accidental extra line break) (M)
###

function check_discontiguous_trailers ()
{
    local rev="$1"

    while read -r; do
        if [[ -z "$(get_trailer "${REPLY}" "${rev}")" ]]; then
            nonmaintainer_error "${REPLY} looks like a trailer but is not recognized by Git"
        fi
    done < <(git log -1 --format=%b  "${rev}" | \
                 sed -n 's/^\([[:upper:]][[:alpha:]-]*\):[[:space:]].*/\1/p')
}

function check_revert ()
{
    local rev="$1"
    local subject

    if [[ -z "${IS_REVERT}" || "${ALLOW_STANDARD_GIT_REVERT}" == "true" ]]; then
        return 0
    fi

    fixes="$(get_trailer "Fixes" "${rev}")"

    if [[ -z "${fixes}" ]]; then
        serious_error 'no Fixes trailer in a revert commit'
    else
        subject="$(git log -1 --format='%s' "${rev}")"
        subject="${subject#revert: }"
        fixes="${fixes#*: }"
        fixes="${fixes%\")}"

        if [[ "${subject}" != "${fixes}" ]]; then
            serious_error "subject and Fixes trailer mismatch in a revert commit"
        fi
    fi
}

#shellcheck disable=SC2034
while read -r localref localsha remoteref remotesha; do
    echo "$localref $localsha $remoteref $remotesha" >&2
    # Local branch is deleted, nothing to do
    [[ "${localsha}" == "${Z40}" ]] && continue

    # Do not check tags separately
    [[ "${remoteref}" == refs/tags/* ]] && continue

    # If a new branch is created, we should check
    # all
    if test "${remotesha}" = "${Z40}"; then
        range="@{u}..${localsha}"
    else
        range="${remotesha}..${localsha}"
    fi

    PRODUCTION_BRANCH=
    PRIVATE_BRANCH=
    if [[ "${remoteref}" == refs/heads/user/${LOGNAME}/* ]]; then
            PRIVATE_BRANCH=1
    else
        for prod in ${PROD_BRANCHES}; do
            if [[ "${remoteref}" == */${prod} ]]; then
                PRODUCTION_BRANCH=1
                break
            fi
        done
    fi

    if [[ "${MAINTAINER_PUSH}" != "true" && -z "${PRODUCTION_BRANCH}" && \
              -z "${PRIVATE_BRANCH}" ]]; then
        echo "NOTICE: checking a push to a non-production branch" \
             "'${remoteref#refs/heads/}'" >&2
        echo "        Configured production branches are: ${PROD_BRANCHES//$'\n'/ }" >&2
    fi

    for rev in $(git rev-list "${range}"); do
        header="${COMMIT_NAMES[${rev}]:-}"
        if [[ -z "${header}" ]]; then
            header="$(git log -1 --oneline "${rev}")"
        fi
        ERRORS=""
        WARNINGS=""

        IS_REVERT=""
        if [[ "$(git log -1 --format='%s' "${rev}")" == Revert\ \"*\" ]]; then
            if [[ "${ALLOW_STANDARD_GIT_REVERT}" == "true" ]]; then
                IS_REVERT=true
            else
                serious_error "standard Git reverts are prohibited"
            fi
        else
            [[ "$(git log -1 --format='%s' "${rev}")" == revert:\ * ]] && \
                IS_REVERT=true
        fi

        [[ "${PUSH_VERBOSE_CHECKS}" == "true" ]] && echo "Checking ${COMMIT_NAMES[${rev}]:-${rev}}" >&2
        check_signed_off "${rev}"
        check_co_developers "${rev}"
        check_reviewed_by "${rev}"
        check_reviewed_by_dups "${rev}"
        check_capitalization "${rev}"
        check_fixes "${rev}"
        check_trailer_syntax "${rev}"
        check_trailer_ordering "${rev}"
        check_summary "${rev}"
        check_description "${rev}"
        check_whitespaces "${rev}"
        check_nonascii "${rev}"
        check_nonascii_body "${rev}"
        check_required_review "${rev}"
        check_prohibited_trailers "${rev}"
        check_extra_trailers "${rev}"
        check_discontiguous_trailers "${rev}"
        check_revert "${rev}"

        if [[ -n "${ERRORS}${WARNINGS}" ]]; then
            echo "${header}${ERRORS}${WARNINGS}" >&2
        fi
    done
done < "${reflist}"

exit "${NOTOK}"
